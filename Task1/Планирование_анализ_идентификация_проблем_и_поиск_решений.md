# Планирование: анализ, идентификация проблем и поиск решений

## 1) Кратко о текущей архитектуре (as-is)

- **Онлайн-магазин** (Vue) → **Shop API** (Spring Boot) → **Shop DB** (PostgreSQL)
- **CRM** (Vue) → **CRM API** (Spring Boot) → (собственная БД на схеме не показана, но по описанию логика CRM есть)
- **MES** (React) → **MES API** (C#) → **MES DB** (PostgreSQL)
- **RabbitMQ** — обмен событиями/статусами между CRM и MES.
- **S3-хранилище 3D-файлов** — файлы для расчёта.
- **Инфра**: 3 окружения (dev/release/prod), у каждого приложения **по одному инстансу**. БД — managed single instance read/write.
- **Процессы**: dev — авто, release/prod — вручную. QA гоняет E2E вручную, из‑за high/highest багов релизы часто задерживаются.

## 2) Идентифицированные проблемные места

### 2.1. Надёжность и целостность бизнес-процесса заказа
1. **Заказы “зависают” на месяцы**, хотя производство по мощности справляется → вероятно, проблема в ИТ-потоке: потеря/дублирование событий, рассинхрон статусов, “застрявшие” состояния.
2. **Сильная распределённость статусов** (магазин → MES → CRM → MES → CRM) без явного “владельца” процесса. Риск: нет единого источника истины по жизненному циклу заказа.
3. **Интеграция через RabbitMQ** без упоминания:
   - идемпотентности обработчиков,
   - гарантированной доставки (outbox/CDC),
   - DLQ/повторных попыток,
   - мониторинга лагов/ошибок консьюмеров.
   Это типичный источник “потерянных” или “дублированных” заказов.
4. **B2B сценарий**: заказ создаётся в CRM “по сообщению от MES” → высокая вероятность сложной логики, гонок статусов и ошибок сопоставления заказов (особенно при росте нагрузки).

### 2.2. Производительность и масштабирование
5. **Единичные инстансы всех приложений** → SPOF и отсутствие горизонтального масштабирования при линейном росте заказов.
6. **Тяжёлый расчёт цены в MES** (2–3 мин, до 30 мин) → если расчёт выполняется “внутри” MES API/в общих ресурсах, он способен:
   - выедать CPU/RAM,
   - блокировать пул потоков,
   - тормозить UI MES (включая “первую страницу”).
7. **Первая страница MES тормозит даже после фильтра и пагинации** → симптомы:
   - тяжёлые запросы к БД (сканы, сортировки без индексов),
   - отсутствие read-оптимизированной модели,
   - возможно, конкуренция с расчётами/фоновыми задачами за ресурсы.
8. **Операторам критично видеть самые новые заказы** → если сортировка/выборка идёт “по статусам” без правильных индексов и без ограничений по времени, будет деградация с ростом данных.

### 2.3. Данные и согласованность
9. **Две (или больше) БД** (Shop DB, MES DB, вероятно CRM DB) → риск:
   - разные идентификаторы заказа,
   - сложная корреляция,
   - отсутствие “истины” по статусу/дедлайнам/приоритетам.
10. **Нет явного механизма сверки**: что делать, если событие не дошло или дошло дважды.

### 2.4. Операционка и релизы
11. **Ручные деплои в release/prod** + ручные E2E → медленные релизы, накопление долга, высокий риск “застревания” проблем в проде.
12. **Отсутствие явной наблюдаемости (observability)** в описании:
   - распределённые трассировки,
   - метрики очереди, воркеров, времени расчёта,
   - алерты на “заказ не менял статус N часов/дней”.
   Без этого проблемы проявляются только через жалобы пользователей.

## 3) Инициативы для устранения нежелательных ситуаций

Ниже — список инициатив (от крупных до локальных). Формулирую как “что сделать” + ожидаемый эффект.

### A. Надёжность событий и управление жизненным циклом заказа
A1. **Ввести контракт событий и единый OrderID (корреляция)**
- Описать события (OrderSubmitted, PriceCalculated, ManufacturingApproved, …), обязательные поля, версии.
- Единый ключ корреляции во всех системах.
- Эффект: снижение рассинхрона и “потерянных” заказов из‑за сопоставления.

A2. **Идемпотентность обработчиков + дедупликация**
- Каждый consumer обрабатывает событие “не более одного логического раза”.
- Хранить обработанные messageId/версии статуса.
- Эффект: безопасность при повторах RabbitMQ.

A3. **Outbox-паттерн (или CDC) для публикации событий из БД**
- Событие пишется в локальную БД транзакционно вместе с изменением состояния заказа.
- Отдельный процесс публикует в RabbitMQ.
- Эффект: резко меньше “состояние обновилось, но событие не ушло”.

A4. **DLQ + retry policy + алерты на ошибки консьюмеров**
- Чёткие правила ретраев, dead-letter-очереди, ручная/авто переработка.
- Эффект: события не “пропадают молча”.

A5. **Сверка состояний (reconciliation job)**
- Периодически находит заказы, которые “застряли” (не меняли статус X часов/дней) и чинит/эскалирует.
- Эффект: из “месяцами висит” → “обнаружили и поправили/эскалировали за часы”.

### B. Производительность: расчёт цены и тяжёлые операции
B1. **Вынести расчёт цены в отдельный воркер/сервис**
- MES API превращается в “оркестратор”: кладёт задачу в очередь, воркеры считают.
- Масштабируемый пул воркеров (по CPU), отдельные лимиты/автоскейлинг.
- Эффект: UI MES и API перестают “задыхаться” от расчётов.

B2. **Очередь задач расчёта + статусы прогресса**
- Явный статус “CALCULATING_PRICE”, таймауты, повторная постановка.
- Эффект: прозрачность для B2C/B2B и меньше жалоб “ничего не происходит”.

B3. **Кэширование/переиспользование результатов по хэшу 3D-модели (опционально)**
- Если одна и та же модель (или слегка изменённая) — не пересчитывать с нуля.
- Эффект: экономия времени/ресурсов при повторных запросах.

### C. Производительность: MES “первая страница” и выбор самых новых заказов
C1. **Профилирование и оптимизация запросов MES DB**
- Индексы по (status, created_at/updated_at), покрывающие индексы под dashboard.
- Убрать N+1, тяжёлые JOIN без необходимости.
- Эффект: быстрый выигрыш без перестройки архитектуры.

C2. **Read-модель для дашборда (CQRS-lite)**
- Отдельная таблица/материализованное представление “orders_dashboard”.
- Обновление событиями/триггерами/фоновой задачей.
- Эффект: стабильная скорость при росте данных.

C3. **“Лента новых заказов” для операторов**
- UI показывает “самые новые” (по created_at) и автообновляется (polling/WebSocket).
- Эффект: бизнес-цель операторов достигается без тяжёлой аналитики на лету.

C4. **Атомарное “взятие в работу” (claim)**
- Оператор “захватывает” заказ одной транзакцией (optimistic lock/version).
- Эффект: меньше гонок “кто первый взял — тот и получил”.

### D. Масштабирование и устойчивость инфраструктуры
D1. **Добавить горизонтальное масштабирование приложений**
- Минимум: поднять 2+ инстанса для MES API и CRM API (и Shop API при необходимости) за балансировщиком.
- Эффект: устойчивость к пикам и отказоустойчивость на уровне приложений.

D2. **Read replica для БД или разделение чтения/записи (где возможно)**
- Отдельные реплики для “дашборда” и тяжёлых чтений.
- Эффект: снимаем нагрузку с primary.

D3. **Ресурсные лимиты и изоляция тяжёлых задач**
- Воркеры расчёта не конкурируют за ресурсы с API/UI.
- Эффект: предсказуемость.

### E. Процессы разработки и качество
E1. **Автоматизация критичных E2E (smoke)**
- Минимальный набор автотестов для “заказ прошёл жизненный цикл”.
- Эффект: меньше блокировок релиза из‑за ручных прогонов и поздних находок.

E2. **Ускорение релизного цикла**
- Полуавтоматизация деплоя в release/prod (кнопка в CI), чек‑листы, canary/blue-green (по возможностям).
- Эффект: быстрее доставляем фиксы, меньше “месяцами ждём”.

E3. **Observability как продукт**
- Метрики: лаги очередей, время расчёта, ошибки консьюмеров, “заказы застряли”.
- Логи с корреляцией OrderID, трассировки между сервисами.
- Эффект: проблемы видны до жалоб.

## 4) Приоритизация инициатив (с аргументацией)

Ниже — приоритеты в порядке “сначала”, исходя из критерия: **прекратить потери/зависания заказов и вернуть предсказуемость сроков**, а затем — масштабировать и ускорять релизы.

### Приоритет 1 
1) **A2 + A4 + E3 (идемпотентность + DLQ/ретраи + наблюдаемость)**
- Почему: если сейчас события теряются/дублируются/падают консьюмеры, любые оптимизации UI не спасут — заказы продолжат “пропадать”.
- Результат: видим, где ломается, и перестаём терять события “тихо”.

2) **B1 (вынести расчёт цены в воркеры)**
- Почему: расчёт — самый тяжёлый этап и он усиливается ростом заказов; он же способен деградировать всё MES.
- Результат: стабилизация MES и увеличение пропускной способности.

3) **C1 (быстрая оптимизация запросов/индексов для MES дашборда)**
- Почему: операторы жалуются ежедневно; это влияет на скорость взятия заказов и на сроки.
- Результат: быстрый эффект (дни/недели), пока делаем более крупные изменения.

### Приоритет 2 
4) **A3 (Outbox)**
- Почему: это “золотой стандарт” для надёжной интеграции при нескольких БД/сервисах.
- Результат: меньше расхождений состояния и событий.

5) **A5 (reconciliation)**
- Почему: даже с outbox и ретраями будут edge-cases; нужен “пылесос”, который находит застрявшее.
- Результат: SLA по “вылечить зависший заказ”.

6) **C2 (read-модель для дашборда)**
- Почему: рост данных линейный, а тормоза будут расти нелинейно без read-оптимизации.
- Результат: прогнозируемая скорость дашборда при росте.

### Приоритет 3 
7) **D1 (2+ инстанса критичных API)**
- Почему: один инстанс = простой при сбое/обновлении.
- Результат: меньше даунтайма и больше “запаса”.

8) **E1/E2 (автотесты + улучшение релизов)**
- Почему: чтобы не “лечить месяцами”, а выкатывать фиксы быстро и безопасно.
- Результат: ускорение улучшений, снижение риска регресса.

9) **D2 (read replicas)**
- Почему: полезно, но сначала надо понять профиль нагрузки и оптимизировать запросы.
- Результат: дополнительный запас производительности.

## 5) Целевая архитектура через полгода (to-be, 6 месяцев)

Я вижу её так:

1. **Событийная шина (RabbitMQ) используется “правильно”**
   - Контракты событий, версии, единый OrderID.
   - Идемпотентные консьюмеры, дедупликация, DLQ, ретраи.
   - Outbox в системах, которые публикуют критичные события.

2. **Расчёт цены — отдельный масштабируемый контур**
   - Очередь задач расчёта + воркеры (горизонтально масштабируются).
   - MES API не выполняет CPU-heavy работу синхронно.
   - Прозрачные статусы и метрики времени расчёта.

3. **MES UI работает на read-оптимизированной модели**
   - Быстрый дашборд “новые/в работе заказы”, сортировка по времени.
   - Атомарный “claim” заказа оператором.
   - (Опционально) отдельный read-store (таблица, materialized view, или иной storage) для списка/агрегаций.

4. **Наблюдаемость и контроль процесса**
   - Дашборды и алерты: лаги очередей, процент ошибок, застрявшие статусы, p95 расчёта.
   - Reconciliation job регулярно “прочёсывает” аномалии.

5. **Базовая устойчивость инфраструктуры**
   - 2+ инстанса у критичных API, балансировка.
   - Воркеры расчёта изолированы по ресурсам.
   - Релизы быстрее: есть автосмоук/минимальные E2E.

## 6) Если сделать только 3 пункта за полгода — что выбираю и почему

### 1) Надёжная интеграция: A2 + A4 + E3 (идемпотентность, DLQ/ретраи, наблюдаемость)
**Почему:** это напрямую бьёт по главной боли — “заказа нет / завис месяцами”.  
Без этого любые улучшения производительности будут маскировать проблему, но не решать её.  
**Что получим:** контролируемость процесса заказа, снижение потерь/дубликатов, быстрые реакции на сбои.

### 2) Вынести расчёт цены в воркеры: B1 (+B2 по возможности)
**Почему:** расчёт — самое тяжёлое место и будет только хуже с ростом заказов. Он также может “класть” MES.  
**Что получим:** рост пропускной способности, предсказуемость, снижение деградаций UI/API.

### 3) MES дашборд: C1 (оптимизация запросов/индексов) → с заделом на C2
**Почему:** операторам критично брать **самые новые** заказы, от этого зависят сроки и деньги.  
Это заметная боль “каждый день”, и она напрямую влияет на выполнение заказов.  
**Что получим:** быстрый UI, меньше простоя операторов, быстрее старт производства.

> Почему не выбираю в топ-3 “масштабировать всё” (D1) и “улучшить релизы” (E2) как первые?
> Потому что сначала нужно прекратить потери/зависания и изолировать тяжёлые вычисления.
> Масштабирование без исправления надёжности событий может просто ускорить генерацию проблем (дубликаты/гонки).
> А ускорение релизов важно, но оно даёт эффект только если мы уже знаем, *что* исправлять и умеем это наблюдать.

