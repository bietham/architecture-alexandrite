# Архитектурное решение по трейсингу

## 0) Цель

Сделать так, чтобы команда могла по **order_id** (и для B2B по **api_client_id**) быстро ответить на вопросы:
- где сейчас находится заказ и на каком шаге он “застрял”;
- какой сервис/очередь/операция стала причиной задержки;
- было ли сообщение потеряно, обработано повторно или упало в DLQ.

---

## 1) Анализ системы в контексте трейсинга: где заказ может “сломаться” или зависнуть

Ниже перечислены зоны риска и компоненты, которые нужно покрыть распределённым трейсингом (энд-ту-энд).

### 1.1. Компоненты, которые покрываем трейсингом в первую очередь
1) **Shop API (Spring Boot)**  
   Риск: заказ создаётся, файл загружен, но дальше процесс не стартует или “зависает” на вызовах/публикациях.

2) **MES API (C#)**  
   Риск: самый тяжёлый этап (расчёт цены), возможны таймауты, ошибки чтения 3D-файла, нехватка ресурсов, блокировки.

3) **CRM API (Spring Boot)**  
   Риск: подтверждение производства и закрытие заказа, задержки из-за интеграций и ошибок обработчиков.

4) **RabbitMQ (интеграция CRM ↔ MES)**  
   Риск: потеря сообщений, дубликаты, долгий backlog, DLQ, консьюмеры не ack’ают.

5) **3D files storage (S3)**  
   Риск: файл недоступен, не хватает прав, ошибки скачивания, большой размер, “битые” файлы.

6) **Shop DB / MES DB (PostgreSQL managed)**  
   Риск: долгие запросы, блокировки, исчерпание коннектов, рост времени ответа API.

> Фронтенды (Internet Shop, CRM UI, MES UI) можно подключить позже через RUM (браузерный трейсинг), но критичный минимум для расследования “зависаний заказов” это бэкенды + RabbitMQ + S3 + БД.

### 1.2. Типовые места разрыва процесса (что хотим видеть в трейсах)
- Публикация события в RabbitMQ произошла, а обработчик в другой системе:
  - не получил,
  - получил, но упал,
  - получил и обработал повторно,
  - положил в DLQ.
- Расчёт цены:
  - начался, но завис на чтении S3,
  - упёрся в CPU/память,
  - длится сильно дольше нормы (p95/p99),
  - завершился, но результат не “прилетел” дальше по процессу.
- “Первая страница MES”:
  - долгие запросы к MES DB,
  - блокировки/коннекты,
  - деградация из-за конкуренции с тяжёлыми операциями.
- Рассинхрон статусов между системами:
  - в одной системе статус обновился, а событие о статусе не дошло.

---

## 2) Данные, которые должны попадать в трейсинг

### 2.1. Технические поля трейсинга (минимум)
- `trace_id`, `span_id`, `parent_span_id`
- `timestamp_start`, `duration`
- `service.name`, `service.version`, `env` (dev/release/prod)
- `host/instance` (где выполнялся span)
- `span.kind` (server/client/producer/consumer)
- `status` (OK/ERROR), `error.message` (без персональных данных), `error.type`

### 2.2. Бизнес-корреляция (чтобы искать “по заказу”)
- `order_id` (ключевой атрибут, обязателен везде, где заказ уже известен)
- `order_status` и `order_status_prev` (для span’ов смены статуса)
- `order_source` (b2c/b2b)
- `api_client_id` (для B2B, если есть идентификатор клиента)
- `user_id` или `customer_id` (если нужно, лучше в виде хэша/псевдонима)
- `operator_id` (когда заказ взят в работу)

### 2.3. HTTP-контекст (для API)
- `http.method`, `http.route` (или endpoint), `http.status_code`
- `client.ip` не хранить в открытом виде, только если реально нужно и строго ограничено доступом
- `request_size_bytes`, `response_size_bytes` (без тела запроса)

### 2.4. RabbitMQ-контекст (для асинхронных цепочек)
- `messaging.system=rabbitmq`
- `messaging.destination` (queue), `messaging.destination_kind`
- `messaging.rabbitmq.exchange`, `routing_key`
- `message_id` (уникальный id сообщения)
- `delivery_tag` (при необходимости)
- `retry_count` (если реализованы ретраи)
- `dlq_reason` (если попадание в DLQ)

### 2.5. S3/файлы 3D
- `storage.system=s3`
- `bucket`, `object_key` (или безопасный `file_id`, лучше не светить полный key)
- `file_size_bytes`
- (опционально) `model_complexity` (например, `polygons_count` или “бакет сложности”), если доступно и не дорого считать

### 2.6. БД (PostgreSQL)
- `db.system=postgresql`
- `db.name`, `db.operation` (select/insert/update)
- `db.statement` не сохранять целиком, лучше ограничиться:
  - `db.query_name` (идентификатор запроса)
  - `db.rows_affected`
- `db.duration`
- `db.pool.wait_time` (если есть)

### 2.7. Важное ограничение по данным
- Не пишем в трейс: токены, пароли, номера карт, полные персональные данные, содержимое 3D-файлов, полные тела запросов/ответов.
- Всё, что потенциально PII, либо исключаем, либо хэшируем и жёстко ограничиваем доступ.

---

## 3) Мотивация

### 3.1. Почему трейсинг нужен прямо сейчас
- Проблема “заказ завис в непонятном состоянии” типична для распределённых систем с очередями.
- Метрики (мониторинг) показывают симптомы (рост очереди, 5xx, CPU), но не всегда показывают конкретную историю одного заказа.
- Трейсинг позволяет “пройти путь заказа” и увидеть: на каком шаге и почему всё остановилось.

### 3.2. Что это даст компании
- Быстрее находим корневую причину, меньше времени простоя и меньше жалоб.
- Уменьшаем число потерянных/зависших заказов за счёт видимости “провалов” в интеграции.
- Можем вводить SLA и управлять ростом заказов на фактах.

### 3.3. Метрики, на которые повлияет внедрение трейсинга (3–5)
Технические:
1) **MTTR (mean time to recovery)**  
   Трейсы сокращают время диагностики и исправления инцидентов.

2) **Error rate (доля ошибок) в цепочке обработки заказа**  
   Видно, где именно возникают ошибки (API, очередь, S3, БД).

3) **Latency p95/p99 по критичным операциям**  
   Например, “получение дашборда MES”, “расчёт цены”, “публикация/консюм события”.

Бизнес-метрики:
4) **Доля заказов, “застрявших” в статусе дольше порога** (например, > 24 часов на стадиях до производства)  
   Трейсинг помогает быстро классифицировать причины и убрать узкие места.

5) **Снижение количества обращений/жалоб по статусу заказа**  
   Потому что поддержка и продавцы видят, где заказ находится, и могут дать корректный ответ.

---

## 4) Предлагаемое решение

### 4.1. Технология
Рекомендуем базироваться на **OpenTelemetry (OTel)** как на стандарте:
- единый формат данных трейсинга,
- готовые библиотеки/агенты для Java и .NET,
- поддержка контекстной пропагации через HTTP и брокеры сообщений.

Вариант хранилища/визуализации:
- **OTel Collector** (центральная точка приёма, обработка, семплинг, экспорт),
- **Jaeger** как trace backend,
- **Jaeger UI** для поиска и просмотра трасс.

Почему так:
- быстрое внедрение без переписывания всей системы,
- можно постепенно расширять покрытие.

### 4.2. Что нужно внедрить/доработать по компонентам
1) **Shop API (Spring Boot)**
- Подключить OpenTelemetry Java agent или SDK.
- Включить propagation `traceparent` (W3C Trace Context) для исходящих HTTP.
- Добавить `order_id` в span attributes, когда заказ уже создан.

2) **CRM API (Spring Boot)**
- То же: OTel agent/SDK, propagation.
- Инструментировать обработчики RabbitMQ (consumer/producer spans).
- Везде прокидывать `order_id` и `message_id`.

3) **MES API (.NET)**
- Подключить OpenTelemetry .NET SDK.
- Инструментировать HTTP endpoints и ключевые операции:
  - расчёт цены,
  - чтение 3D-файла из S3,
  - операции с БД,
  - публикацию событий в RabbitMQ.

4) **RabbitMQ**
- Для сообщений добавлять/читать trace context в headers:
  - `traceparent` + `tracestate`,
  - дополнительно `order_id`, `message_id`, `retry_count` (как прикладные headers).
- При обработке сообщения создавать span типа consumer, связанный с исходным trace.

5) **S3**
- Инструментировать клиент S3: отдельные spans на upload/download.
- Ошибки и таймауты должны попадать в трейс.

6) **Центральный сбор**
- Развернуть **OpenTelemetry Collector** (желательно минимум 2 инстанса для надёжности).
- Настроить семплинг:
  - 100% для ошибок и очень долгих операций,
  - 5–20% для успешных (настраивается по нагрузке).
- Экспортировать в Tempo/Jaeger.

7) **Корреляция с логами**
- В каждый лог писать `trace_id` и `order_id` (структурированные логи).
- Это позволит по трейсу сразу прыгать в логи.

### 4.3. Правки в C4-диаграмму 

![](jewerly_c4_model.drawio%20(1).png)

---

## 5) Компромиссы и ограничения

1) **Длинные бизнес-процессы (дни/недели)**
- Один “непрерывный” trace на недели держать бессмысленно и дорого.
- Подход: трейсить каждую транзакцию (шаг процесса) и связывать их по `order_id`.
- Для расследования “месяцами висит” нужны процессные метрики и события статусов (это дополняет трейсинг).

2) **Нагрузка и стоимость хранения**
- Трейсы могут быть объёмными, особенно при высоком RPS и 100% семплинге.
- Компромисс: семплинг, фильтрация, ограничение атрибутов, ретеншн 7–14 дней для детальных трейс, дольше только для ошибок.

3) **Сложность инструментирования проприетарных/устаревших частей**
- Если где-то используется “нестандартная” библиотека RabbitMQ/клиент S3, может потребоваться ручная обвязка.
- Компромисс: начать с основных входов/выходов и постепенно расширять покрытие.

4) **Риск утечки чувствительных данных**
- Если без правил писать тела запросов и персональные данные, это создаст риск.
- Компромисс: строгая политика атрибутов, маскирование, запрет на payload, доступ по ролям.

---

## 6) Безопасность трейсинга

### 6.1. Доступ внутри компании
- Включить **аутентификацию** для UI (Grafana/Jaeger UI): доступ только сотрудникам с актуальной учёткой.
- **RBAC**: роли “Поддержка”, “Разработчик”, “Администратор”.
- Разделение по окружениям: доступ к prod отдельно и более строго.

### 6.2. Доступ снаружи
- Не публиковать UI трейсинга в интернет.
- Доступ только через VPN/бастион или корпоративную сеть.
- Если нужен внешний доступ (редко): только через SSO + MFA и allowlist.

### 6.3. Защита данных
- TLS на всех соединениях (сервисы → Collector, Collector → Backend, UI → Backend).
- Шифрование данных “at rest” (диски/хранилище).
- Retention policy: хранить детальные трейс ограниченное время.
- Политика данных: запрет на токены/PII, маскирование `user_id` и прочего.

### 6.4. Аудит
- Логи доступа к UI и изменения настроек.
- Отдельный audit trail для админских действий.
