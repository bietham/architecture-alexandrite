@startuml
title MES caching: read dashboard + update status

actor Operator as OP
participant "MES UI (React)" as UI
participant "MES API (C#)" as API
database "MES DB (PostgreSQL)" as DB
collections "Redis Cache" as REDIS
queue "RabbitMQ" as MQ

== 1) Read: get newest orders list for status ==
OP -> UI: Open dashboard page
UI -> API: GET /orders?status=NEW&limit=50&cursor=...
activate API

API -> REDIS: ZRANGE mes:orders:status:NEW:zset (0..49) WITHSCORES
alt Cache hit (IDs found)
  REDIS --> API: [order_id1..order_id50]
  API -> REDIS: MGET/HMGET mes:order:{id}:hash for 50 ids
  alt Details cache hit (most)
    REDIS --> API: order DTOs (or partial)
    API --> UI: 200 OK (orders list)
  else Details cache miss (some)
    REDIS --> API: partial/missing
    API -> DB: SELECT ... FROM orders WHERE id IN (...)
    DB --> API: rows
    API -> REDIS: HMSET mes:order:{id}:hash (TTL 10-30m)
    API --> UI: 200 OK (orders list)
  end
else Cache miss (no IDs / empty or expired)
  REDIS --> API: empty
  API -> DB: SELECT id, created_at FROM orders
    note right
    WHERE status='NEW'
    ORDER BY created_at DESC
    LIMIT 50
    end note
  DB --> API: [ids + created_at]
  API -> REDIS: ZADD mes:orders:status:NEW:zset (id, created_at) (TTL optional)
  API -> REDIS: HMSET mes:order:{id}:hash (TTL 10-30m)
  API --> UI: 200 OK (orders list)
end
deactivate API

== 2) Write: change order status (claim / progress) ==
OP -> UI: Click "Take order" / change status
UI -> API: POST /orders/{order_id}/status {new_status=MANUFACTURING_STARTED}
activate API

API -> DB: BEGIN
API -> DB: UPDATE orders
note right
SET status=?, updated_at=now(), operator_id=?
WHERE id=? AND status IN (allowed)
RETURNING prev_status, created_at
end note
alt Update success
  DB --> API: prev_status, created_at

  ' Update cache (programmatic invalidation + update index)
  API -> REDIS: HSET mes:order:{order_id}:hash status=new_status, operator_id=...
  API -> REDIS: ZREM mes:orders:status:{prev_status}:zset {order_id}
  API -> REDIS: ZADD mes:orders:status:{new_status}:zset (order_id, created_at or updated_at)

  ' Optional: invalidate hot page caches for both statuses
  API -> REDIS: DEL mes:orders:page:{prev_status}:* (patterned via tags/set-of-keys)
  API -> REDIS: DEL mes:orders:page:{new_status}:*

  API -> DB: COMMIT

  ' Notify other systems (if required by process)
  API -> MQ: Publish OrderStatusChanged {order_id, prev_status, new_status, message_id, traceparent}
  API --> UI: 200 OK
else Conflict / not allowed
  DB --> API: 0 rows (conflict)
  API -> DB: ROLLBACK
  API --> UI: 409 CONFLICT (order already taken / status changed)
end
deactivate API

@enduml